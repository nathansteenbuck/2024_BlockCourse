---
title: "05_CellCategories_cells_Compressed"
author: "Nathan Steenbuck"
date: "Created: 23 Oct, 2024; Compiled: `r format(Sys.time(), '%d %b, %')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
script_name <- "05_CellCategories_cells_Uncompressed.Rmd"

source(file.path("/", "mnt", "central_nas", "projects", 
                 "type1_diabetes", "nathan", "BlockCourse", "2024_BlockCourse", "T1D_analysis", 
                "helpers.R"))
n_cores <- 2
future::plan(future::multicore(workers = n_cores))
paths <- getPaths(script_name)
knitr::opts_knit$set(root_dir = paths$cluster_home)
do_print <- TRUE

seed <- 123456
set.seed(seed)
options <- furrr::furrr_options(seed = seed)
paths$prev <- paste("04_QualityControl", paths$object_type, paths$panel_type, sep = "_")
knitr::opts_chunk$set(echo = TRUE)
```

# **Goal**

In the following scripts, cell types are attributed to all cells in the dataset
in an iterative way:

Rscript -e "rmarkdown::render('2024_BlockCourse/T1D_analysis/05_CellCategories_cells_Uncompressed.Rmd')"

- `05_CellCategories_cells_Uncompressed` (this script): Attribution of cell types from the uncompressed dataset.

This is performed by performing PhenoGraph clustering using the Rphenoannoy package.

For cell type annotation we perform unsupervised clustering, and then relate the lineage marker expression of clusters to cell types.

The resulting cell categories, which are used in downstream analyses are stored
as `colData(spe)$cell_type`.

# **Settings**

## Load packages

```{r packages, results="hide"}
suppressPackageStartupMessages(c(
  library(data.table),
  library(dplyr),
  library(SpatialExperiment),
  library(parallel),
  library(tictoc),
  library(purrr),
  library(furrr)
))
```

## Paths and settings

```{r settings}
# Paths
if (!dir.exists(paths$folder_script)) dir.create(paths$folder_script)
plotsave_param$path <- paths$folder_script
plotsave_param_large$path <- paths$folder_script

# Misc settings
today <- gsub("-", "", Sys.Date())
```

##  Read in the data

Load the SpatialExperiment (SPE) object saved at the previous step.

```{r load-data}
fn_spe <- file.path(paths$folder_out, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
spe <- readRDS(fn_spe)
print(spe)
```

```{r}
imgloader <- function(x, image_dir, image_names,
                     suffix_rem = "", suffix_add = "",
                     bit_depth = 16, type, ...) {
  require(cytomapper)

  image_list <- file.path(image_dir, image_names)

  # Test if the image list exist
  test_exist <- which(!file.exists(image_list))
  if (length(test_exist) > 0) {
    stop(c("The following images were not found:\n",
           paste(image_list[test_exist], collapse = "\n")))
  } else {
    # Load and scale the images
    images <- loadImages(image_list, ...)
    # images <- scaleImages(images, (2 ^ bit.depth) - 1)

    # Add image names to metadata
    mcols(images)$ImageName <- gsub(suffix_rem, "", names(images))
    mcols(images)$ImageName <- paste0(mcols(images)$ImageName, suffix_add)

    # Add channel names
    if (type == "stacks") {
      print("Loading image stacks")
      channelNames(images) <- rownames(x)
    }

    return(images)
  }
}
```


# **Clustering**

## Settings

### Load packages

RPhenoannoy can installed with: `devtools::install_github("stuchly/Rphenoannoy@8b81e2e7fb0599f45070e2cba1b28ac219b7c472")`

```{r packages2, results="hide"}
suppressPackageStartupMessages(c(
  library(ggplot2),
  library(scater),
  library(scuttle),
  library(scran),
  library(igraph),
  library(Rphenoannoy),
  library(clustree),
  library(ranger),
  library(patchwork),
  library(BiocParallel),
  library(tictoc)
))
```

### Channels and assays

Select channels (`channels_clust`), assays (`assay_sel`) and clustering methods (`methods_sel`) to use.

```{r select-methods-assays}
methods_sel <- c("Pheno1")

assay_sel <- c("scaled")
names(assay_sel) <- c("scaled")

writeLines(c("Assays:", assay_sel[assay_sel %in% assayNames(spe)], 
                        assay_sel[assay_sel %in% reducedDimNames(spe)]))

dimred_sel <- c("UMAP")
writeLines(c("\nReduced dimensions:", dimred_sel))

channels <- rownames(spe)[!(grepl("DNA|H3", rownames(spe)))]
cat(c("\nChannels:", channels[channels %in% rownames(spe)]))
cat(c("\nNumber of channels:", length(channels)))
```

### Select channels to use for clustering

Reduced dimension plots showing marker expression that generated by the previous script 
can be used to select the most relevant markers for clustering.

```{r select-channels-clustering}
channels_clust <- rownames(rowData(spe)[rowData(spe)$clustering == 1, ])
cat(c("\nChannels used for unsupervised clustering:",
      channels_clust[channels_clust %in% rownames(spe)]))
```


## Subset

```{r convert-to-sce}
# Extract the metadata (to avoid conflicts when merging the SCEs)
meta <- metadata(spe)
spatial_coords <- spatialCoords(spe)
colpairs <- colPairs(spe)

# Convert to SingleCellExperiment
sce <- as(spe, "SingleCellExperiment")
remove(spe)
```

## **Clustering: PhenoGraph**

Unsupervised clustering is performed with the [PhenoGraph](https://doi.org/10.1016/j.cell.2015.05.047) algorithm. 
This method works by generating a nearest-neighbor (kNN) graph of phenotpyic similarities followed by Louvain community dectection. 

Here, we try the [Rphenoannoy implementation](https://github.com/stuchly/Rphenoannoy).
RPhenoannoy implements a parallel Jaccard-coefficient, approximates the kNN and uses Louvain clustering.

```{r phenograph-run}
clust_method <- c("Pheno1")

# Number of nearest-neighbors
k <- 30
cur_assay <- "scaled"

# Run Phenograph - PhenoGraph for exprs and scaled assay.

clust_name <- paste(clust_method, cur_assay, sep = "_")
writeLines(c("\n", clust_name))

if (!clust_name %in% colnames(colData(sce))) {
  set.seed(seed)
  # Run Rphenograph.
  cur_pheno_annoy <- Rphenoannoy::Rphenoannoy(t(assay(sce, cur_assay))[, channels_clust], k = k)

  cur_pheno <- DataFrame(cur_pheno_annoy[[2]]$membership)
  colnames(cur_pheno) <- clust_name
  rownames(cur_pheno) <- colnames(assay(sce, cur_assay))

  # Add Phenograph clusters to the colData of the SCE object
  # Cluster `0` is attributed to non-subsetted cells and not islet cells
  colData(sce)[, clust_name] <- cur_pheno
  remove(cur_pheno)
  }
```

# **Visualize clusters**

## Load packages

```{r packages3, results="hide"}
suppressPackageStartupMessages(c(
  library(heatmaply),
  library(htmltools)#,
  #library(cytomapper)
))
```


## Visualize clusters on reduced dimensions
RUN UMAP again.


```{r subset-spe}
set.seed(222)
if (!("subset" %in% names(metadata(sce)))) {
  # Cells per case
  nb_cells <- 7500
  
  # Subset the SPE object (nb_cells per case)
  cell_subset <- tibble(rn = rownames(colData(sce)),
                        case_id = colData(sce)$case_id) |> 
    group_by(case_id) |>
    sample_n(nb_cells) |> 
    pull(rn)
  
  # Keep the subset cell ids in SPE metadata
  metadata(sce)[["subset"]] <- sort(as.vector(cell_subset))
}

# Keep only the selected cells and channels
spe_sub <- sce[channels_clust, metadata(sce)[["subset"]]]
```

```{r run-UMAP}
# Add UMAPs to SPE object
cur_assay <- "scaled"
dimred_name <- paste("UMAP", cur_assay, sep = "_")
print(dimred_name)

# Run UMAP on a cell subset
if ((!dimred_name %in% reducedDimNames(spe_sub)) && ("UMAP" %in% dimred_sel)) {
  #Â Extract Counts. 
  if (cur_assay %in% assayNames(spe_sub)) {
    counts <- t(assay(spe_sub, cur_assay))
  }
  # Run UMAP.
  umap_model <- uwot::umap(counts, ret_model = TRUE)
  # Extract Embedding.
  cur_umap <- umap_model$embedding
  colnames(cur_umap) <- c("UMAP1", "UMAP2")
  rownames(cur_umap) <- rownames(counts)
}

reducedDim(spe_sub, dimred_name) <- cur_umap
```

```{r dimred-clusters}
cur_method <- "Pheno1"
cur_dimred <- "UMAP"
cur_dat <- makePerCellDF(spe_sub, use_dimred = TRUE) |>
  dplyr::arrange(case_id, donor_type)  |> 
  tibble::as_tibble()

dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
clust_name <- paste(cur_method, cur_assay, sep = "_")

# Plot all clustersdat, dimred, color_by
p <- plot_dim_red(dat = cur_dat, dimred = dimred_name, color_by = clust_name,
                  sample = TRUE, size = 0.1, alpha = 1)
print(p)
fn <- paste0(paste(today, "Clusters", clust_name, cur_dimred,
                    sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))
```


## Heatmap of marker expression by cluster
```{r heatmap-clusters-markers}
name_cur_assay <- "scaled"
clust_name <- paste(cur_method, cur_assay, sep = "_")
message(clust_name)

channels_clust2 <- channels_clust[!channels_clust %in% c("Rb", "FOXP3", "PTPRN", "CD20")]
# Summarize the data
hm <- summarize_heatmap(sce,
                        expr_values = name_cur_assay,
                        cluster_by = clust_name,
                        channels = channels_clust2)

# Display the heatmap
fn <- paste0(paste(today, "Clusters", clust_name, "Heatmap",
                    sep = "_"), ".html")
heatmaply(
    heatmaply::normalize(hm), main = clust_name, 
    file = file.path(paths$folder_script, fn))

# remove all clusters with less than 10 cells and plot again.
clust_freq <- table(colData(sce)[[clust_name]])
clust_freq
```

Rare Clusters: 12, 24, 21, 22 (all below 200).


## Visualize clusters with cytomapper and cytoviewer

Here, we use the `cytoviewer` package to visualize the clusters on the images.
Thereby, we can check if the clusters are biologically meaningful and if they indeed correspond to the respective cell types.

Additional information we can use is their spatial localization of cell types, i.e. which cells in the endocrine or exocrine compartment.

### Select cluster(s) and assay to show

```{r viz-clust-select}
# viz_clust <- c(26, 23, 12) # Select cluster(s) to visualize.
viz_clust <- NULL
viz_method <- "Pheno1"
viz_assay <- "scaled"
```

### Load images and masks

```{r viz-cluster-load}
if (!is.null(viz_clust)) {
  nb_images <- 14
  image_extension <- ".tiff"
  clust_name <- paste(viz_method, viz_assay, sep = "_")

  # Subset the SCE
  sce_viz <- sce[, colData(sce)[[clust_name]] %in% viz_clust]

  # Select random image.
  set.seed(seed)
  image_sub <- sort(sample(
    unique(sce_viz$image_fullname),
  min(length(unique(sce_viz$image_fullname)), nb_images)))

  # Folders
  folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
  folder_masks <- file.path(paths$folder_in, "masks_cells",
                            paths$panel_type, "whole-cell")

  # Load images and masks
  images <- imgloader(
    x = sce_viz,
    image_dir = folder_images,
    image_names = image_sub,
    type = "stacks"
  )

  masks <- imgloader(
    x = sce_viz,
    image_dir = folder_masks,
    image_names = image_sub,
    as.is = TRUE,
    type = "masks"
  )

  sce_viz <- sce_viz[, sce_viz$image_fullname %in% image_sub]
  sce_viz$ImageName <- gsub(image_extension, "", sce_viz$image_fullname)
}
```

### Interactive with Cytoviewer

```{r viz-cluster-cytoviewer}
# Use cytoviewer with images, masks and object
library(cytoviewer)
if (!is.null(viz_clust)) {
  channels_view <- channels_clust
  sub_images <- cytomapper::getChannels(images, channels_view)
  app <- cytoviewer(image = sub_images, 
                    mask = masks, 
                    object = sce_viz[channels_view, ], 
                    img_id = "ImageName", 
                    cell_id = "cell_number")

  if (interactive()) {
    shiny::runApp(app)
  }
}
```

# **Attribute cell categories**

**Note: this section requires manual intervention**

Here, clusters obtained at the previous steps are manually merged into meaningful cell types.
Cluster numbers are attributed to the different cell types based on the plots and heatmaps above. 
Consequently, this attribution has to be adapted to the clustering results.

## Cell category attribution

Cell category attribution has to be performed for every combination of clustering methods and selected assays.

### Phenograph x scaled counts

Depending on the clustering, maybe select other categories.

```{r cellcats-pheno-scaled}
clust_methods <- c("Pheno1")
clust_assay <- c("scaled")

if (!clust_assay %in% assay_sel) stop("The selected assay is not in the assays selected for clustering")
if (length(clust_assay) != 1) ("Select only one assay")

clust_name <- paste(clust_methods, clust_assay, sep = "_")
print(clust_name)

# Islet:
clust_beta <- c(15, 14) # 
clust_alpha <- c(16, 24)
clust_delta <- c(18)
clust_gamma <- c(12)
clust_islet_other <- c(13) # 

# Immune:
clust_t <- c(11)
clust_neutrophil <- c(22)
clust_myeloid <- c(20)

# Exocrine Cells + Stromal.
clust_endothelial <- c(7)
clust_mesenchymal <- c(21)

clust_ductal <- c(9, 1, 17, 19)
clust_acinar <- c(26, 2:6, 8)
clust_other <- c(10, 23, 25)

all_clust <- sort(c(clust_alpha, clust_beta, clust_delta, clust_gamma, clust_islet_other,
                    clust_t,  clust_neutrophil, clust_myeloid,
                    clust_endothelial, clust_mesenchymal, 
                    clust_ductal, clust_acinar, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
# Islet
colData(sce)[colData(sce)[, clust_name] %in% clust_alpha,
             "cell_type"] <- "Alpha"
colData(sce)[colData(sce)[, clust_name] %in% clust_beta,
              "cell_type"] <- "Beta"
colData(sce)[colData(sce)[, clust_name] %in% clust_delta,
              "cell_type"] <- "Delta"
colData(sce)[colData(sce)[, clust_name] %in% clust_gamma,
               "cell_type"]<- "Gamma"
colData(sce)[colData(sce)[, clust_name] %in% clust_islet_other,
              "cell_type"] <- "Islet_Other"

# Immune:
colData(sce)[colData(sce)[, clust_name] %in% clust_t,
             "cell_type"] <- "T_cell"
colData(sce)[colData(sce)[, clust_name] %in% clust_myeloid,
             "cell_type"] <- "Myeloid"
colData(sce)[colData(sce)[, clust_name] %in% clust_neutrophil,
              "cell_type"] <- "Neutrophil"

# Exocrine
colData(sce)[colData(sce)[, clust_name] %in% clust_ductal,
              "cell_type"] <- "Ductal"
colData(sce)[colData(sce)[, clust_name] %in% clust_acinar,
              "cell_type"] <- "Acinar"

# Stroma:
colData(sce)[colData(sce)[, clust_name] %in% clust_endothelial,
              "cell_type"] <- "Endothelial"
colData(sce)[colData(sce)[, clust_name] %in% clust_mesenchymal,
              "cell_type"] <- "Fibro_SM"

# Other
colData(sce)[colData(sce)[, clust_name] %in% clust_other,
              "cell_type"] <- "Other"
```

Assign Cell Categories base don the assigned cell types.
```{r cell_cats}
# Islet-category (Alpha, Beta, Delta, Gamma)
colData(sce)[colData(sce)[, "cell_type"] %in% c("Alpha", "Beta", "Delta", "Gamma", "Islet_Other"),
             "cell_category"] <- "Islet"

# Immune-category (Lympho, Myeloid, Neutrophil)
colData(sce)[colData(sce)[, "cell_type"] %in% c("T_cell", "Myeloid", "Neutrophil"),
             "cell_category"] <- "Immune"

# Exocrine-category (Ductal, Acinar)
colData(sce)[colData(sce)[, "cell_type"] %in% c("Ductal", "Acinar"),
              "cell_category"] <- "Exocrine"
# Stroma-category (Endothelial, Fibro_Endo)
colData(sce)[colData(sce)[, "cell_type"] %in% c("Endothelial", "Fibro_SM"),
              "cell_category"] <- "Stroma"

# Other-category (Other)
colData(sce)[colData(sce)[, "cell_type"] %in% c("Other"),
              "cell_category"] <- "Other"
```

### Plot cell types on reduced dimensions

```{r cellcats-dimred}
spe_sub$Pheno1_scaled <- sce[, colnames(spe_sub)]$Pheno1_scaled
spe_sub$cell_type <- sce[, colnames(spe_sub)]$cell_type

# Prepare the data
cur_dat <- makePerCellDF(spe_sub, use_dimred = TRUE) |>
  arrange(case_id, donor_type)

# Plot
cur_assay <- "scaled"
cur_dimred <- "UMAP"
cur_method <- "Pheno1"

dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
clust_name <- "cell_type"

p <- plot_dim_red(cur_dat, dimred_name, clust_name,
                  sample = TRUE, size = 1, alpha = 1)
print(p)

fn <- paste0(paste(today, clust_name, cur_dimred,
                  sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))
```

### Cell Types heatmap

```{r cellcats-heatmap}
channels_clust2 <- channels_clust[!channels_clust %in% 
                    c("Rb", "FOXP3", "CD45RA", "PTPRN", "CD20")]

cur_assay <- "scaled"
name_cur_assay <- "scaled"
clust_name <- "cell_type"

# Summarize the data
hm <- summarize_heatmap(sce,
                        expr_values = name_cur_assay,
                        cluster_by = clust_name,
                        channels = channels_clust2)

# Display the heatmap
fn <- paste0(paste(today, clust_name, "Heatmap",
                sep = "_"), ".html")

set.seed(222)
heatmaply(
heatmaply::normalize(hm), main = clust_name,
file = file.path(paths$folder_script, fn))
```


### Number of cells by cell category

```{r cells-per-category}
table(colData(sce)[, "cell_type"])
table(colData(sce)[, "cell_category"])
```


# **Plot cell categories**

## Reduced dimensions

Plot consensus cell categories on reduced dimensions

```{r consensus-dimred}
spe_sub$cell_category <- sce[, colnames(spe_sub)]$cell_category

ccat <- c("Immune", "Islet", "Exocrine", "Stroma", "Other")
names(ccat) <- c("Immune", "Islet", "Exocrine", "Stroma", "Other")
palette_ccat <- c(palettes$colors[1:(length(ccat) - 2)], "grey40", "grey")
names(palette_ccat) <- ccat

cur_dat <- scuttle::makePerCellDF(spe_sub,
                                  use_dimred = TRUE) |>
  arrange(case_id, donor_type)

dimred_name <- paste(cur_dimred, cur_assay, sep = "_")

p <- plot_dim_red(cur_dat, dimred_name, "cell_category",
                  sample = TRUE, size = 0.1, alpha = 1,
                  palette = palette_ccat)
print(p)

fn <- paste0(paste(today, "CellCat", "Consensus", dimred_name,
                    sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))
```

## Heatmap

```{r consensus-heatmap}
clust_name <- paste("cell_category", cur_assay, sep = "_")

# Summarize the data
hm <- summarize_heatmap(sce,
                        expr_values = cur_assay,
                        cluster_by = "cell_category",
                        channels = channels)

# Display the heatmap
fn <- paste0(paste(today, "CellCat", "Consensus", cur_assay,
                    "Heatmap", sep = "_"), ".html")

heatmaply(
  heatmaply::normalize(hm), main = clust_name,
  file = file.path(paths$folder_script, fn))
```

# **Save **

## Remove temporary columns

## Save SCE

```{r save-sce}
fn <- file.path(paths$folder_out, paste0(paths$object_type, "_", paths$panel_type, "sce.rds"))
saveRDS(sce, fn)
```

