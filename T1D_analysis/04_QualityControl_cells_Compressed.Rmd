---
title: "04_QualityControl_cells_Immune"
author: "Nathan Steenbuck, Nicolas Damond"
date: "Created: 23 May, 2022; Compiled: `r format(Sys.time(), '%d %b, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
script_name <- "04_QualityControl_cells_Immune.Rmd"

source(file.path("/", "Users", "nathan", "2024_BlockCourse", "T1D_analysis", "helpers.R"))
n_cores <- 2
future::plan(future::multicore(workers = n_cores))
paths <- getPaths(script_name)
knitr::opts_knit$set(root_dir = paths$cluster_home)
do_print <- TRUE

# Misc. Settings.
seed <- 123456
set.seed(seed)
options <- furrr::furrr_options(seed = seed)
options(future.globals.maxSize = 50 * 1024 * 1024 * 1024)
knitr::opts_chunk$set(echo = TRUE)
paths$prev <- paste("03_TransformCorrect", paths$object_type, paths$panel_type, sep = "_")
```

## **Goals**  
  
Perform quality controls on cell-level data.   
  
**Diagnostic plots**  
- Number of cells and images per condition  
- Density plots  
- 90th percentile per channel  
- Heatmaps  
- Low-level representations: PCA, MDS, MNF  
- Shannon entropy / ion counts  

**Dimensionality reduction**  
- UMAP  
- Plot key variables (stage, cases) on reduced dimensions.  
- Plot marker abundances on reduced dimensions.  

**Image visualization**  
- Display images with `cytomapper` for visual quality check.  
- Display images before/after spillover-compensation.  



# **Settings**  

## Load packages

```{r packages, results='hide'}
suppressPackageStartupMessages(c(
  library(data.table),
  library(dplyr),
  library(SpatialExperiment),
  library(parallel),
  library(furrr),
  library(tictoc)
))
```

## Paths and settings

```{r settings}
# Paths
if (!dir.exists(paths$folder_script)) dir.create(paths$folder_script)
plotsave_param$path <- paths$folder_script
plotsave_param_large$path <- paths$folder_script

# Misc settings
today <- gsub("-", "", Sys.Date())
```

##  Read in the data

Load the SpatialExperiment (SPE) object saved at the previous step.

```{r load-data}
fn_spe <- file.path(paths$folder_out, paths$prev, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
spe <- readRDS(fn_spe)
print(spe)
```



# **Diagnostic plots**

```{r packages2, results='hide', include=FALSE}
suppressPackageStartupMessages(c(
  library(vroom),
  library(RColorBrewer),
  library(ggplot2),
  library(ggridges),
  library(scuttle),
  library(scater),
  library(dittoSeq),
  library(heatmaply),
  library(htmltools),
  library(BiocParallel),
  library(ggrepel),
  library(EBImage)
  #library(foreach),
  #library(doParallel)
))
```

## Order rows

Load a file that indicates in which order the data should be plotted.
The content of this file is then saved in the metadata slot of the SPE object.

```{r row-order}
# Load the file
fn_order <- file.path(paths$folder_in, "order.csv")
if (!file.exists(fn_order)) stop("Ordering file not found")
row_order <- vroom(fn_order, show_col_types = FALSE)

# Row order for cases and stages
stages <- row_order[!is.na(row_order$stages), ]$stages
stages <- stages[stages %in% spe$donor_type]
cases  <- row_order[!is.na(row_order$cases), ]$cases
cases <- cases[cases %in% spe$case_id]

# Save to metadata
metadata(spe)[["stages"]] <- stages
metadata(spe)[["cases"]] <- cases
```

## Select assays and channels

Modify the `assay_sel` variable to select which assay (for instance scaled counts (`scaled`) or asinh-transformed counts (`exprs`)) should be used for quality control plots. 
Multiple assays can be entered but this leads to increased processing times.

```{r select-assays}
# Select the assay(s) of interest
assay_sel <- c("counts", "scaled", "exprs", "fastMNN_case_id")
writeLines(c("Assays:", assay_sel[assay_sel %in% assayNames(spe)]))

# Select the channels to display
channels <- rownames(spe)[!(grepl("DNA|H3", rownames(spe)))]
writeLines(c("\nNumber of channels:", length(channels)))

# Variables to plot
plot_variables <- c("stages", "cases")
plot_variables2 <- c("stages", "casestages")
names(plot_variables2) <- names(plot_variables) <- c("donor_type", "case_id")
writeLines("\nVariables to plot:")
print(plot_variables)
```

Change the case_id column to a factor.
```{r factor_column}
colData(spe)[, "case_id"] <- factor(colData(spe)[, "case_id"])
```

## Subset the SPE object

The SPE object is subset to `nb_cells` per case for faster plotting. Hence, for example `2000 cells` per donor.

```{r subset-spe}
if (!("subset" %in% names(metadata(spe)))) {
  # Cells per case
  nb_cells <- 2000
  
  # Subset the SPE object (nb_cells per case)
  cell_subset <- tibble(rn = rownames(colData(spe)),
                        case_id = colData(spe)$case_id) |> 
    group_by(case_id) |>
    sample_n(nb_cells) |> 
    pull(rn)
  
  # Keep the subset cell ids in SPE metadata
  metadata(spe)[["subset"]] <- sort(as.vector(cell_subset))
}

# Keep only the selected cells and channels
spe_sub <- spe[channels, metadata(spe)[["subset"]]]
```


## Number of images and cells per case and stage

Plot the number of images per case and stage.

```{r images-per-condition}
# Calculate number of images per case and stage
cur_dat <- as_tibble(colData(spe)) |>
  dplyr::distinct(case_id, donor_type, image_id) |>
  dplyr::count(case_id, donor_type) |>
  dplyr::mutate(case_id = factor(case_id, levels = metadata(spe)$cases),
                donor_type = factor(donor_type, levels = metadata(spe)$stages)) |>
  dplyr::arrange(case_id, donor_type)

# Plot number of images per case
p <- cur_dat |>
  ggplot(aes(y = n,
             x = as.factor(donor_type),
             color = as.factor(donor_type))) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter() +
  expand_limits(y = 0) +
  scale_color_manual(values = palettes$stages) +
  labs(color = "T1D stage", x = NULL, y = "Number of images per case") +
  mytheme$standard() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p)

fn <- paste0(paste(today, "Number", "ImagesPerCase", sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))

# Plot total number of images per disease stage
p <- cur_dat |>
  ggplot(aes(y = n,
             x = as.factor(donor_type),
             fill = as.factor(donor_type))) +
  geom_bar(stat = "identity") +
  expand_limits(y = 0) +
  scale_fill_manual(values = palettes$stages) +
  labs(fill = "T1D stage", x = NULL, y = "Total number of images per stage") +
  mytheme$standard() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p)

fn <- paste0(paste(today, "Number", "ImagesPerStage", sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))
```

Plot the number of measured cells per case and per stage.

```{r cells-per-condition}
# Calculate number of cells per case and stage
cur_dat <- as_tibble(colData(spe)) |>
  group_by(case_id, donor_type) |>
  summarise(n = n(), .groups = "keep") |>
  mutate(case_id = factor(case_id, levels = metadata(spe)$cases),
         donor_type = factor(donor_type, levels = metadata(spe)$stages)) |>
  arrange(case_id, donor_type)

# Plot number of cells per case
p <- cur_dat |>
  ggplot(aes(y = n,
             x = as.factor(donor_type),
             color = as.factor(donor_type))) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter() +
  expand_limits(y = 0) +
  scale_color_manual(values = palettes$stages) +
  labs(color = "T1D stage", x = NULL, y = "Number of cells per case") +
  mytheme$standard() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

fn <- paste0(paste(today, "Number", "CellsPerCase", sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))

# Plot number of cells per disease stage
p <- cur_dat |>
  ggplot(aes(y = n,
             x = as.factor(donor_type),
             fill = as.factor(donor_type))) +
  geom_bar(stat = "identity") +
  expand_limits(y = 0) +
  scale_fill_manual(values = palettes$stages) +
  labs(fill = "T1D stage", x = NULL, y = "Total number of cells per stage") +
  mytheme$standard() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

fn <- paste0(paste(today, "Number", "CellsPerStage", sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))
```

Plot the number of cells per image.

```{r cells-per-image}
# Calculate number of cells per case and stage
cur_dat <- as_tibble(colData(spe)) |>
  group_by(case_id, donor_type, image_id) |>
  summarise(n = n(), .groups = "keep") |>
  mutate(case_id = factor(case_id, levels = metadata(spe)$cases),
         donor_type = factor(donor_type, levels = metadata(spe)$stages)) |>
  arrange(case_id, donor_type)

# Plot number of cells per image and per case
p <- cur_dat |>
  ggplot(aes(y = n,
             x = as.factor(case_id),
             color = as.factor(donor_type))) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(size = 0.5) +
  expand_limits(y = 0) +
  scale_color_manual(values = palettes$stages) +
  labs(color = "Case", x = NULL, y = "Number of cells per image") +
  mytheme$standard() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
p

fn <- paste0(paste(today, "Number", "CellsPerImage", "byCase",
                   sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))


# Plot number of cells per image and per stage
cur_dat <- cur_dat |>
  group_by(case_id, donor_type) |>
  summarise(avg = mean(n), .groups = "keep")
  
p <- cur_dat |>
  ggplot(aes(y = avg,
             x = as.factor(donor_type),
             color = as.factor(donor_type))) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter() +
  expand_limits(y = 0) +
  scale_color_manual(values = palettes$stages) +
  labs(color = "T1D stage", x = NULL, y = "Average number of cells per image") +
  mytheme$standard() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

fn <- paste0(paste(today, "Number", "CellsPerImage", "byStage",
                   sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))
```


## Density plots

For the different transformations, check the distribution of each marker intensity to identify potential global shifts and drop outs.

```{r density-plots, message=FALSE, fig.height=10, fig.width=15}
furrr::future_walk(assay_sel, \(cur_assay) {
  # Create tibble with image number, cell number, case and intensity values.
  cur_dat <- dplyr::bind_cols(
    image_numer = colData(spe_sub)$image_number,
    cell_number = colData(spe_sub)$cell_number,
    case_id = colData(spe_sub)$case_id,
    t(assay(spe_sub, cur_assay)))
  
  # Pivot longer into channel and intensity columns
  cur_dat <- cur_dat |>
    tidyr::pivot_longer(cols = -c(image_numer, cell_number, case_id), 
                        names_to = "channel", values_to = cur_assay)  |> 
    dplyr::filter(channel %in% channels)  |> 
    dplyr::arrange(case_id)
  
  # Plot Intensity distribution for all channels and donors.
  p <- cur_dat |> 
    ggplot(aes(x = get(cur_assay), y = as.factor(case_id))) +
    geom_density_ridges(aes(fill = as.factor(case_id), color = "black"),
                        size = 0.2, alpha = 0.5) +
    facet_wrap(~channel) +
    scale_fill_manual(values = palettes$casestages) +
    scale_color_manual(values = palettes$stages) +
    ggtitle(paste("ChannelsperDonor", "-", cur_assay)) +
    guides(fill = FALSE) +
    labs(x = cur_assay, y = "Case", color = "T1D stage") +
    mytheme$standard() +
    theme(axis.text.y = element_text(size = 3))
  
  # Save.
  fn <- paste0(paste(today, "DensityPlots", "ChannelsperDonor",
                     cur_assay, sep = "_"), ".png")
  do.call(ggsave, c(list(fn, p), plotsave_param_large))
}, .options = options)
```


## 90th percentile

Calculate the 90th percentile intensity in each channel for all donors.

```{r 90-percentile, fig.height=10, fig.width=15}
furrr::future_walk(.x = assay_sel, .f = \(cur_assay) {
  # we only need the case id from colData
  # get entire counts data frame. 
  cur_dat <- dplyr::bind_cols(
    case_id = colData(spe_sub)$case_id,
    t(assay(spe_sub, cur_assay))
  )

  # Calculate 90th percentile of each channel (column-wise) and each case
  cur_dat <- cur_dat |> 
    group_by(case_id) |>
    summarise(across(all_of(channels), \(x) quantile(x, probs = 0.9)))

  cur_dat <- cur_dat |> 
    tidyr::pivot_longer(cols = -case_id, names_to = "channel", values_to = "perc")
  
  # Plot percentiles
  p <- cur_dat |>
    ggplot(aes(x = as.factor(case_id), y = perc, fill = as.factor(case_id))) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = palettes$casestages) +
    facet_wrap(~channel, scales = "free") +
    labs(x = "Cases", y = "Counts 90th percentile", fill = "Cases") +
    mytheme$standard() +
    theme(
      legend.position = "none",
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 3)
    )

  fn <- paste0(paste(today, "90thPercentiles", cur_assay, sep = "_"), ".png")
  do.call(ggsave, c(list(fn, p), plotsave_param_large))
}, .options = options)
```


## Heatmaps

### Interactive heatmaps

Interactive heatmaps of feature expression are generated using the [heatmaply package](https://github.com/talgalili/heatmaply).

```{r heatmap-case-stage}
hmlist <- list()
hmlist <- replicate(n = length(plot_variables2), expr = list())
names(hmlist) <- plot_variables2

purrr::walk2(assay_sel, seq_along(assay_sel), \(cur_assay, idx_assay) {
  purrr::walk2(plot_variables2, seq_along(plot_variables2), \(plot_x, idx_plots) {
    # Prepare the data. summarize_heatmap defined in helpers.R
    hm <- summarize_heatmap(spe_sub, cur_assay,
                            names(plot_variables2)[idx_plots], channels, "mean")
    # Row-side colors
    cur_var <- metadata(spe)[[plot_x]]
    rowsidecol <- cur_var[order(match(cur_var, rownames(hm)))]
    rowsidepal <- palettes[[plot_x]]
    rowsidepal <- rowsidepal[names(rowsidepal) %in% rownames(hm)]
    rowsidepal <- rowsidepal[order(match(names(rowsidepal), rownames(hm)))]
    # Define file name
    fn <- paste0(paste(today, "Heatmap", plot_x, cur_assay, sep = "_"), ".html")

    # Plot heatmap
    hmlist[[idx_plots]][[idx_assay]] <- heatmaply(
      heatmaply::normalize(hm),
      RowSideColors = rowsidepal, row_side_palette = rowsidepal,
      seriate = "OLO",
      main = paste(plot_x, cur_assay, sep = " - "),
      file = file.path(paths$folder_script, fn))
  })
})
htmltools::tagList(setNames(hmlist, NULL))
```

### Visualize mean expression levels

Heatmaps are generated with the [dittoSeq package](http://www.bioconductor.org/packages/release/bioc/html/dittoSeq.html).  

Prepare the data:  
* Calculate mean marker intensity per case.
* Transform counts.

```{r calculate-mean-expr}
# Workaround for *** hardcoded `sample_id` in `SpatialExperiment`
sce <- as(spe, "SingleCellExperiment")
sce$sample_id <- sce$image_id

# Calculate mean intensities
sce_mean <- scuttle::aggregateAcrossCells(sce,
                                          ids = sce$case_id,
                                          statistics = "mean",
                                          use.dimred = FALSE)
colnames(sce_mean) <- sce_mean$case_id
remove(sce)

# Asinh-transformed counts
assay(sce_mean, "exprs") <- asinh(assay(sce_mean, "counts"))

# Quantile-normalized counts
censor_val <- 0.999
quant <- apply(assay(sce_mean, "counts"), 1, quantile, probs = censor_val)
assay(sce_mean, "scaled") <- apply(assay(sce_mean, "counts"), 2,
                                   function(x) x / quant)
assay(sce_mean)[assay(sce_mean, "scaled") > 1] <- 1
assay(sce_mean, "scaled")[assay(sce_mean, "scaled") < 0] <- 0

# Select assays for ploting mean marker intensities
assay_sel_mean <- c("counts", "exprs", "scaled")
```

Heatmaps of marker intensities without scaling

```{r dittoheatmap-not-scaled}
purrr::walk(assay_sel_mean, \(cur_assay) {
  h <- dittoHeatmap(sce_mean, assay = cur_assay,
                    annot.by = c("case_id", "donor_type"),
                    order.by = match(cases, sce_mean$case_id),
                    scale = "none", heatmap.colors = viridis(100),
                    cluster_cols = FALSE,
                    main = paste("Heatmap", "NotScaled", cur_assay,
                                 sep = " - "),
                    annotation_colors = list(case_id = palettes$cases,
                                             donor_type = palettes$stages),
                    genes = channels)
  fn <- paste0(paste(today, "HeatmapDitto", "NotScaled",
                     cur_assay, sep = "_"), ".png")
  do.call(ggsave, c(list(fn, h), plotsave_param))
})
```

Centered and scaled mean marker intensities

```{r dittoheatmap-centered-scaled}
purrr::walk(assay_sel_mean, \(cur_assay) {
  h <- dittoHeatmap(sce_mean, assay = cur_assay,
                    annot.by = c("case_id", "donor_type"),
                    order.by = match(cases, sce_mean$case_id),
                    heatmap.colors = colorRampPalette(
                    c("dark blue", "white", "dark red"))(100),
                    cluster_cols = FALSE,
                    main = paste("Heatmap", "Cent + Scaled", cur_assay,
                                 sep = " - "),
                    annotation_colors = list(case_id = palettes$cases,
                                             donor_type = palettes$stages),
                    breaks = seq(-3, 3, length.out = 101),
                    genes = channels)
  fn <- paste0(paste(today, "HeatmapDitto", "CenteredScaled",
                     cur_assay, sep = "_"), ".png")
  do.call(ggsave, c(list(fn, h), plotsave_param))
})
```


