---
title: "06_CellTypes_cells_Compressed"
author: "Nathan Steenbuck"
date: "Created: 23 Oct, 2024; Compiled: `r format(Sys.time(), '%d %b, %')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
script_name <- "06_CellTypes_cells_Compressed.Rmd"

source(file.path("/", "mnt", "central_nas", "projects", 
                 "type1_diabetes", "nathan", "BlockCourse", "2024_BlockCourse", "T1D_analysis", 
                "helpers.R"))
n_cores <- 2
future::plan(future::multicore(workers = n_cores))
paths <- getPaths(script_name)
knitr::opts_knit$set(root_dir = paths$cluster_home)
do_print <- TRUE

seed <- 123456
set.seed(seed)
options <- furrr::furrr_options(seed = seed)
paths$prev <- paste("05_CellCategories", paths$object_type, paths$panel_type, sep = "_")
knitr::opts_chunk$set(echo = TRUE)
```



# **Goal**

In the following scripts, cell types are attributed to all cells in the dataset
in an iterative way:

- `05_CellCategories_cells_Compressed`: Attribution of main categories (immune, islet, other (exocrine+stroma)).
- `06_CellTypes_cells_Compressed`: Attribution of cell types (this script).

In both scripts this is performed by performing PhenoGraph clustering using the Rphenoannoy package.

The resulting cell categories, which are used in downstream analyses are stored
as `colData(spe)$cell_category`.


# **Settings**

## Load packages

```{r packages, results="hide"}
suppressPackageStartupMessages(c(
  library(data.table),
  library(dplyr),
  library(SpatialExperiment),
  library(parallel),
  library(tictoc),
  library(purrr),
  library(furrr)
))
```

## Paths and settings

```{r settings}
# Paths
if (!dir.exists(paths$folder_script)) dir.create(paths$folder_script)
plotsave_param$path <- paths$folder_script
plotsave_param_large$path <- paths$folder_script

# Misc settings
today <- gsub("-", "", Sys.Date())
```

##  Read in the data

Load the SpatialExperiment (SPE) object saved at the previous step.

```{r load-data}
fn_spe <- file.path(paths$folder_out, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
spe <- readRDS(fn_spe)
print(spe)
```



# **Clustering**

## Settings

### Load packages

```{r packages2, results="hide"}
suppressPackageStartupMessages(c(
  library(ggplot2),
  library(scater),
  library(scuttle),
  library(scran),
  library(igraph),
  library(Rphenoannoy),
  library(clustree),
  library(ranger),
  library(patchwork),
  library(BiocParallel),
  library(tictoc)
))
```

### Channels and assays

Select channels (`channels_clust`), assays (`assay_sel`) and clustering methods (`methods_sel`) to use.

```{r select-methods-assays}
methods_sel <- c("Pheno1")

assay_sel <- c("scaled")
names(assay_sel) <- c("scaled")

writeLines(c("Assays:", assay_sel[assay_sel %in% assayNames(spe)], 
                        assay_sel[assay_sel %in% reducedDimNames(spe)]))

dimred_sel <- c("UMAP")
writeLines(c("\nReduced dimensions:", dimred_sel))

channels <- rownames(spe)[!(grepl("DNA|H3", rownames(spe)))]
cat(c("\nChannels:", channels[channels %in% rownames(spe)]))
cat(c("\nNumber of channels:", length(channels)))
```

### Select channels to use for clustering

Reduced dimension plots showing marker expression that generated by the previous script 
can be used to select the most relevant markers for clustering.

```{r select-channels-clustering}
channels_clust <- rownames(rowData(spe)[rowData(spe)$clustering == 1, ])
cat(c("\nChannels used for unsupervised clustering:",
      channels_clust[channels_clust %in% rownames(spe)]))
```


## Subset

Now, we create new SCE objects for each cell category


```{r}
sce_isl <- spe[, colData(spe)$cell_category == "Islet"]
sce_immune <- spe[, colData(spe)$cell_category == "Immune"]
sce_exo <- spe[, colData(spe)$cell_category == "Exocrine"]
sce_stroma <- spe[, colData(spe)$cell_category == "Stroma"]
sce_other <- spe[, colData(spe)$cell_category == "Other"]
```


# Channel Decomposition

We will now decompose the channels into their respective signals and noise components.
We have the following assumptions:


Assuming S(CD20) and S(SST) represent the true signals and N(CD20) and N(SST) represent the noise components, 
we can now write the following equations:

- Immune Cells:
  For CD20-positive Immune cells:
    - I(CD20_SST)(Immune) = Signal(CD20)+Noise (SST)
  For CD20-negative Immune cells:
    - I(CD20_SST) Immune = N(CD20) + N(SST)

- Islet Cells:
  For SST-positive Islet cells:
    - I(CD20_SST)(Islet) = S(SST)+N(CD20)
  For SST-negative Islet cells:
    - I(CD20_SST)(Islet) = N(SST)+N(CD20)

- Exocrine Cells:
  For Exocrine cells have both markers as noise:
    - I(CD20_SST)(Exocrine)= N(SST)+N(CD20)


## Perform Channel Decomposition
```{r channels}
channels_compressed <- c("CD44_GCG", "CD8a_INS", "CD4_ProINS", "CD3_NKX6_1", "CD20_SST")
channels_uncompressed <- c("CD44", "GCG", "CD8a", "INS", "CD4", "ProINS", "CD3", "NKX6_1", "CD20", "SST")
```

Fit 2-component GMMs with unequal variance to each channel in each cell category 
to estimate the means("M_") and variances ("V_") of the signal ("S_") and noise ("N_") components.

In addition, extract the threshold value that separates the signal from the noise.

```{r channel_decomposition}
coefficients <- list()
coefficients <- map(channels_compressed, \(channel) {
  # Immune: 
  S_Immune_N_Islet <- mclust::densityMclust(data = assay(sce_immune, "exprs")[channel, ], G = 2, modelNames = "V")
  M_S_Immune_N_Islet <- S_Immune_N_Islet$parameters$mean[2] 
  V_S_Immune_N_Islet <- S_Immune_N_Islet$parameters$variance$sigmasq[2]
  # Extract maximal value for the noise -> threshold value.
  threshold_Immune <- max(S_Immune_N_Islet$data[S_Immune_N_Islet$classification == 1,])
  
  # Islet:
  N_Immune_S_Islet <- mclust::densityMclust(data = assay(sce_isl, "exprs")[channel, ], G = 2, modelNames = "V")
  M_N_Immune_S_Islet <- N_Immune_S_Islet$parameters$mean[2]
  V_N_Immune_S_Islet <- N_Immune_S_Islet$parameters$variance$sigmasq[2]
  threshold_Islet<- max(N_Immune_S_Islet$data[N_Immune_S_Islet$classification == 1,])

  # Exocrine:
  N_Immune_N_Islet <- mclust::densityMclust(data = assay(sce_exo, "exprs")[channel, ], G = 2, modelNames = "V")
  M_N_Immune_N_Islet <- N_Immune_N_Islet$parameters$mean[1]
  V_N_Immune_N_Islet <- N_Immune_N_Islet$parameters$variance$sigmasq[1]
  
  # Stroma:
  I_Stroma <- mclust::densityMclust(data = assay(sce_stroma, "exprs")[channel, ], G = 2, modelNames = "V")$parameters$mean[1]

  coefficients <- c(M_S_Immune_N_Islet, V_S_Immune_N_Islet, 
                    M_N_Immune_S_Islet, V_N_Immune_S_Islet, 
                    M_N_Immune_N_Islet, V_N_Immune_N_Islet,
                    threshold_Islet, threshold_Immune)
  names(coefficients) <- c("M_S_Immune_N_Islet", "V_S_Immune_N_Islet", 
                           "M_N_Immune_S_Islet", "V_N_Immune_S_Islet", 
                           "M_N_Immune_N_Islet", "V_N_Immune_N_Islet",
                           "threshold_Islet", "threshold_Immune")
  coefficients
}) |> 
  bind_rows() |> 
  mutate(channel = channels_compressed)
```

Inspect the coefficients.
```{r}
coefficients
```

## Estimate coefficients of normal distributions (Noise + Signal)
Now, we will decompose the channels into their respective signals and noise components.
Here, we estimate the means and variances of the signal and noise components for each channel in each cell category.

```{r channel_decomposition_2}
estimated_coeffs <- purrr::pmap(coefficients |> dplyr::select(1:6), 
      function(M_S_Immune_N_Islet, V_S_Immune_N_Islet, M_N_Immune_S_Islet, V_N_Immune_S_Islet,
               M_N_Immune_N_Islet, V_N_Immune_N_Islet) {
    
    # As additional constraints we introduce scaling factors between the signal + noise components.
    # Scaling factor between Islet signal (e.g. SST) and Immune signal (e.g. CD20) (estimated from the data)
    fraction_mu <- (M_N_Immune_S_Islet - M_N_Immune_N_Islet/2) /(M_S_Immune_N_Islet- M_N_Immune_N_Islet/2)
    # Scaling factor between sigma SST signal and sigma CD20 signal (estimated from the data)
    # -> This is a strong assumption and might not be true in reality.
    fraction_sigma <- (V_S_Immune_N_Islet - V_N_Immune_N_Islet/2)/(V_N_Immune_S_Islet - V_N_Immune_N_Islet/2)
    # -> we assume that the same fractions apply for the noise. 

    # Augmented coefficient matrix
    A <- rbind(
      c(1, 0, 0, 1, 0, 0, 0, 0),  # M_S_Immune_N_Islet = mu_S_CD20 + mu_N_SST
      c(0, 1, 1, 0, 0, 0, 0, 0),  # M_N_Immune_S_Islet = mu_N_CD20 + mu_S_SST
      c(0, 0, 1, 1, 0, 0, 0, 0),  # M_N_Islet_N_Immune = mu_N_SST + mu_N_CD20

      c(0, 0, 0, 0, 1, 0, 0, 1),  # V_S_Immune_N_Islet = sigma2_S_CD20 + sigma2_N_SST
      c(0, 0, 0, 0, 0, 1, 1, 0),  # V_N_Immune_S_Islet = sigma2_N_CD20 + sigma2_S_SST
      c(0, 0, 0, 0, 0, 0, 1, 1),   # V_N_Immune_N_Islet = sigma2_N_SST + sigma2_N_CD20
      c(fraction_mu, -1, 0, 0, 0, 0, 0, 0),  # fraction_mu * mu_S_CD20 - S_SST = 0
      c(0, 0, 0, 0, fraction_sigma, -1, 0, 0), # fraction_sigma * V_S_CD20 - V_S_SST = 0
      c(0,0,fraction_mu,-1, 0, 0, 0, 0),  # fraction_mu * mu_N_CD20 - mu_N_SST = 0
      c(0,0,0,0, 0, 0, fraction_sigma, -1)  # fraction_sigma * V_N_CD20 - V_N_SST = 0
    )

    # Right-hand side (means and variances combined)
    B <- c(
      M_S_Immune_N_Islet, M_N_Immune_S_Islet, M_N_Immune_N_Islet,
      V_S_Immune_N_Islet, V_N_Immune_S_Islet, V_N_Immune_N_Islet, 0,0,0,0
    )

    # Solve by non-negative least squares
    fit_nnls <- nnls::nnls(A, B)   # Solve the joint system
    coefs <- coef(fit_nnls)

    names(coefs) <- c("mu_S_Immune", "mu_S_Islet", "mu_N_Immune", "mu_N_Islet", 
                      "sigma2_S_Immune", "sigma2_S_Islet", "sigma2_N_Immune", "sigma2_N_Islet")
    coefs
}) |> bind_rows() |> mutate(channel = channels_compressed) 
```

Inspect the estimated coefficients.
Please note: This doesnt work perfect yet, and is the first attempt at algorithmic decomposition. 

```{r}
estimated_coeffs

joint_coeffs <- estimated_coeffs |> 
  dplyr::left_join(coefficients, by = "channel") |> 
  dplyr::select(-dplyr::starts_with("M_"), -dplyr::starts_with("V_"))

full_coeffs <- joint_coeffs |> 
  mutate(sigma2 = sigma2_N_Immune + sigma2_N_Islet) |> 
  mutate(sigma2_N_Immune = sigma2/2) |>
  mutate(sigma2_N_Islet = sigma2/2) |> 
  select(-sigma2)
full_coeffs
```

## Estimate full count density

After estimating the coefficients, we can now estimate the actual counts for each cell.

These are helper functions to estimate:
- The most likely S_Islet and N_Immune for a given positive Islet cell. 
- The most likely N_Islet and S_Immune for a given positive Immune cell.
- The most likely N_Islet and N_Immune in case of noise only.

```{r helper_function}
# Function to calculate the most likely S_Islet and N_Immune
likelihood_s_islet_n_immune <- function(N_Immune, Immune_Islet_obs, mu_Islet, sigma_Islet, mu_N_Immune, sigma_N_Immune) {
  S_Islet <- Immune_Islet_obs - N_Immune  # Compute N_SST from the constraint
  if (N_Immune < 0) return(0)  # Noise cannot be negative
  P_S_Islet <- dnorm(S_Islet, mean = mu_Islet, sd = sigma_Islet)
  P_N_Immune <- dnorm(N_Immune, mean = mu_N_Immune, sd = sigma_N_Immune)
  return(P_S_Islet * P_N_Immune)
}

# Function to calculate the most likely N_Islet and S_Immune
likelihood_n_islet_s_immune <- function(N_Islet, Immune_Islet_obs, mu_Immune, sigma_Immune, mu_N_Islet, sigma_N_Islet) {
  S_Immune <- Immune_Islet_obs - N_Islet  # Compute N_SST from the constraint
  if (N_Islet < 0) return(0)  # Noise cannot be negative
  P_S_Immune <- dnorm(S_Immune, mean = mu_Immune, sd = sigma_Immune)
  P_N_Islet <- dnorm(N_Islet, mean = mu_N_Islet, sd = sigma_N_Islet)
  return(P_S_Immune * P_N_Islet)
}

# Function to calculate the most likely N_Islet and N_Immune in case of noise only.
likelihood_n_islet_n_immune <- function(N_Immune, Immune_Islet_obs, mu_N_Immune, sigma_N_Immune, mu_N_Islet, sigma_N_Islet) {
  N_Islet <- Immune_Islet_obs - N_Immune  # Compute N_SST from the constraint
  if (N_Immune < 0) return(0)  # Noise cannot be negative
  P_N_Immune <- dnorm(N_Immune, mean = mu_N_Immune, sd = sigma_N_Immune)
  P_N_Islet <- dnorm(N_Islet, mean = mu_N_Islet, sd = sigma_N_Islet)
  return(P_N_Immune * P_N_Islet)
}

# Function to calculate the most likely N_Islet and N_Immune in case of noise only.
likelihood_n_islet_n_immune_2 <- function(N_Islet, Immune_Islet_obs, mu_N_Immune, sigma_N_Immune, mu_N_Islet, sigma_N_Islet) {
  N_Immune <- Immune_Islet_obs - N_Islet  # Compute N_SST from the constraint
  if (N_Islet < 0) return(0)  # Noise cannot be negative
  P_N_Immune <- dnorm(N_Immune, mean = mu_N_Immune, sd = sigma_N_Immune)
  P_N_Islet <- dnorm(N_Islet, mean = mu_N_Islet, sd = sigma_N_Islet)
  return(P_N_Immune * P_N_Islet)
}
```

### Decompose for Islet Cells.

```{r estimate-counts}
# IF cell_category is Islet and channel is CD20_SST:
  # Above threshold: signal intensity is SST signal + CD20 noise
  # Below threshold: signal intensity is SST noise  + CD20 noise
library(furrr)
set.seed(222)
options <- furrr::furrr_options(seed = seed)

# Islet cells.
results <- 
  purrr::pmap(full_coeffs, \(mu_S_Immune, mu_S_Islet, mu_N_Immune, mu_N_Islet, sigma2_S_Immune, sigma2_S_Islet, sigma2_N_Immune, sigma2_N_Islet, channel, threshold_Islet, threshold_Immune) {
    message(channel)
    furrr::future_map(1:length(colnames(sce_isl)), \(i) {
      # Get compressed value per cell.
      Immune_Islet_obs <- assay(sce_isl, "exprs")[channel, ][i]
      
      # Define optimization bounds.
      lower_bound1 <- ifelse(mu_N_Immune - sigma2_N_Immune < 0, 0, mu_N_Immune - sigma2_N_Immune)
      upper_bound1 <- ifelse(mu_N_Immune + sigma2_N_Immune > threshold_Immune, threshold_Immune, mu_N_Immune + sigma2_N_Immune)
      interval <- c(lower_bound1, upper_bound1)

      # Catch edge-case.  
      if(Immune_Islet_obs == 0) {
        tibble(Islet = 0, Immune = 0)
      } 
      # Above threshold: signal intensity is SST signal + CD20 noise
      else if(Immune_Islet_obs > threshold_Islet){
          result <- optimize(
            f = likelihood_s_islet_n_immune,
            interval = interval, 
            maximum = TRUE,
            Immune_Islet_obs = Immune_Islet_obs,
            mu_Islet = mu_S_Islet,
            sigma_Islet = sigma2_S_Islet,
            mu_N_Immune = mu_N_Immune,
            sigma_N_Immune = sigma2_N_Immune
          )
          # Extract the results
          N_Immune_opt <- result$maximum
          S_Islet_opt <- Immune_Islet_obs - N_Immune_opt
          tibble(Immune = N_Immune_opt, Islet = S_Islet_opt)
      }
      # Below threshold: signal intensity is SST noise  + CD20 noise
      else{
        result <- optimize(
          f = likelihood_n_islet_n_immune,
          interval = interval,  # N_Immune cannot exceed the N_Immune + Sigma_Immune
          maximum = TRUE,
          Immune_Islet_obs = Immune_Islet_obs,
          mu_N_Immune = mu_N_Immune,
          sigma_N_Immune = sigma2_N_Immune,
          mu_N_Islet = mu_N_Islet,
          sigma_N_Islet = sigma2_N_Islet
        )
        # Extract the results
        N_Immune_opt <- result$maximum
        N_Islet_opt <- Immune_Islet_obs - N_Immune_opt
        tibble(Immune = N_Immune_opt, Islet = N_Islet_opt)
      }
    }, .options = options) |> bind_rows()
})
results_optim <- results |> bind_cols()
colnames(results_optim) <- channels_uncompressed
results_optim
```

Check the results.
```{r plot-islet-decomposition}
channel_oi <- "CD3_NKX6_1"
# Split channels_oi into Immune and Islet
channel_oi2 <- channel_oi |> stringr::str_split("_") |> unlist()
channel_Immune <- channel_oi2[1]
channel_Islet <- ifelse(channel_oi == "CD3_NKX6_1", "NKX6_1", channel_oi2[2])

## Get parameters for the channel of interest
mu_S_Islet <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("mu_S_Islet")
mu_S_Immune <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("mu_S_Immune")
mu_N_Islet <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("mu_N_Islet")
mu_N_Immune <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("mu_N_Immune")
threshold_Immune <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("threshold_Immune")
threshold_Islet <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("threshold_Islet")
sigma2_N_Immune <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("sigma2_N_Immune")
sigma2_N_Islet <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("sigma2_N_Islet")
sigma2_S_Immune <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("sigma2_S_Immune")
sigma2_S_Islet <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("sigma2_S_Islet")

# Compressed channel:
ggplot(tibble(x = assay(sce_isl, "exprs")[channel_oi, ]), aes(x=x)) + geom_density() + 
  geom_vline(xintercept = mu_S_Islet + mu_N_Immune, color = "yellow") + 
  geom_vline(xintercept = mu_S_Islet, color = "red") + 
  geom_vline(xintercept = threshold_Islet, color = "green") + 
  geom_vline(xintercept = mu_N_Islet, color = "blue") + 
  ggtitle(channel_oi)# Density plot:

# Signal Islet Channel
ggplot(results_optim, aes(x = get(channel_Islet))) + geom_density() + 
    geom_vline(xintercept = mu_S_Islet, color = "red") + 
    geom_vline(xintercept = threshold_Islet, color = "green") + 
    geom_vline(xintercept = mu_N_Islet, color = "blue") + 
    ggtitle("Islet")

# Noise Immune Channel
ggplot(results_optim, aes(x = get(channel_Immune))) + geom_density() + 
  geom_vline(xintercept = mu_N_Immune, color = "blue") + 
  ggtitle("Immune")
```

Assign the counts.

```{r islet-count-assigment}
df <- as.data.frame(t(assay(sce_isl, "exprs")))

# Now add the decomposed channels.
# We do not yet remove the compressed channels.
df_decomposed <- df |> 
  mutate(CD44 = results_optim$CD44) |>
  mutate(CD8a = results_optim$CD8a) |> 
  mutate(CD4 = results_optim$CD4) |>
  mutate(CD3 = results_optim$CD3) |>
  mutate(CD20 = results_optim$CD20) |>
  mutate(GCG = results_optim$GCG) |>
  mutate(INS = results_optim$INS) |>
  mutate(SST = results_optim$SST) |> 
  mutate(NKX6_1 = results_optim$NKX6_1) |>
  mutate(ProINS = results_optim$ProINS)

# Uncomrpessed panel now as rowData. 
fn_panel <- file.path(paths$folder_in, paste0("panel_", "Uncompressed", ".csv"))
panel <- read.csv(fn_panel, row.names = 1)

# Create a new SCE object.
sce_isl_2 <- SpatialExperiment(
    assays = list(exprs = as.matrix(t(df_decomposed))), 
    colData = colData(sce_isl), 
    spatialCoords = spatialCoords(sce_isl),
    metadata = metadata(sce_isl),
    rowData = panel)
```


## Decompose for Immune Cells.
Perform the same operation for the Immune cells.
```{r immune-decomposition}
set.seed(222)
options <- furrr::furrr_options(seed = seed)

# Immune: 
results_immun <- purrr::pmap(full_coeffs, \(mu_S_Immune, mu_S_Islet, mu_N_Immune, mu_N_Islet, sigma2_S_Immune, sigma2_S_Islet, sigma2_N_Immune, sigma2_N_Islet, channel, threshold_Islet, threshold_Immune) {
    message(channel)
    results_immune <- furrr::future_map(1:length(colnames(sce_immune)), \(i) {
      # Get compressed value per cell.
      Immune_Islet_obs <- assay(sce_immune, "exprs")[channel, ][i]

      # Catch edge-case.
      if(Immune_Islet_obs == 0) {
        tibble(Immune = 0, Islet = 0)
      } 
      # Above threshold: signal intensity is CD20 signal + SST noise
      else if(Immune_Islet_obs > threshold_Immune){

        # Define optimization bounds.
        # Noise cannot be lower than 0, and within the signal threshold.
        lower_bound1 <- ifelse(mu_N_Islet - sigma2_N_Islet < 0, 0, mu_N_Islet - sigma2_N_Islet)
        upper_bound1 <- ifelse(mu_N_Islet + sigma2_N_Islet > threshold_Islet, threshold_Islet, mu_N_Islet + sigma2_N_Islet)
        interval <- c(lower_bound1, upper_bound1)

        result <- optimize(
          f = likelihood_n_islet_s_immune,
          interval = interval, 
          maximum = TRUE,
          Immune_Islet_obs = Immune_Islet_obs,
          mu_Immune = mu_S_Immune,
          sigma_Immune = sigma2_S_Immune,
          mu_N_Islet = mu_N_Islet,
          sigma_N_Islet = sigma2_N_Islet
        )

        # Extract the results
        N_Islet_opt <- result$maximum
        S_Immune_opt <- Immune_Islet_obs - N_Islet_opt
        tibble(Immune = S_Immune_opt, Islet = N_Islet_opt)
      }
      # Below threshold: signal intensity is SST noise  + CD20 noise
      else{
        # Define optimization bounds. Optimize on Immune noise.
        lower_bound1 <- ifelse(mu_N_Immune - sigma2_N_Immune < 0, 0, mu_N_Immune - sigma2_N_Immune)
        upper_bound1 <- ifelse(mu_N_Immune + sigma2_N_Immune > threshold_Immune, threshold_Immune, mu_N_Immune + sigma2_N_Immune)
        interval <- c(lower_bound1, upper_bound1)

        result <- optimize(
          f = likelihood_n_islet_n_immune,
          interval = interval,  # N_Immune cannot exceed the N_Immune + Sigma_Immune
          maximum = TRUE,
          Immune_Islet_obs = Immune_Islet_obs,
          mu_N_Immune = mu_N_Immune,
          sigma_N_Immune = sigma2_N_Immune,
          mu_N_Islet = mu_N_Islet,
          sigma_N_Islet = sigma2_N_Islet
        )
        # Extract the results
        N_Immune_opt <- result$maximum
        N_Islet_opt <- Immune_Islet_obs - N_Immune_opt
        tibble(Immune = N_Immune_opt, Islet = N_Islet_opt) 
      }
  }) |> bind_rows()
})

results_immune_optim <- results_immun |> bind_cols()
colnames(results_immune_optim) <- channels_uncompressed
results_immune_optim
```

Check the results.
Note: given that the Immune CHannel usually has less signal, the decomposition is more challenging.
```{r plot-immune-islet-decomp}
channel_oi <- "CD20_SST"
# Split channels_oi into Immune and Islet
channel_oi2 <- channel_oi |> stringr::str_split("_") |> unlist()
channel_Immune <- channel_oi2[1]
channel_Islet <- ifelse(channel_oi == "CD3_NKX6_1", "NKX6_1", channel_oi2[2])

## Get parameters for the channel of interest
mu_S_Islet <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("mu_S_Islet")
mu_S_Immune <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("mu_S_Immune")
mu_N_Islet <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("mu_N_Islet")
mu_N_Immune <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("mu_N_Immune")
threshold_Immune <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("threshold_Immune")
threshold_Islet <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("threshold_Islet")
sigma2_N_Immune <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("sigma2_N_Immune")
sigma2_N_Islet <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("sigma2_N_Islet")
sigma2_S_Immune <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("sigma2_S_Immune")
sigma2_S_Islet <- full_coeffs |> dplyr::filter(channel == channel_oi) |> pull("sigma2_S_Islet")

# Compressed channel:
ggplot(tibble(x = assay(sce_immune, "exprs")[channel_oi, ]), aes(x=x)) + geom_density() + 
  geom_vline(xintercept = mu_S_Immune, color = "red") + 
  geom_vline(xintercept = threshold_Immune, color = "green") + 
  geom_vline(xintercept = mu_N_Immune, color = "blue")

# Noise Islet Channel
ggplot(results_immune_optim, aes(x = get(channel_Islet))) + geom_density() + 
    geom_vline(xintercept = mu_N_Islet, color = "blue") + 
    ggtitle("Islet")

# Signal Immune Channel
ggplot(results_immune_optim, aes(x = get(channel_Immune))) + geom_density() + 
  geom_vline(xintercept = mu_S_Immune, color = "red") +
  geom_vline(xintercept = threshold_Immune, color = "green") +
  geom_vline(xintercept = mu_N_Immune, color = "blue") + 
  ggtitle("Immune")
```

Assign the counts.

```{r assign-counts}
df <- as.data.frame(t(assay(sce_immune, "exprs")))

# Now add the decomposed channels.
# We do not yet remove the compressed channels.
df_decomposed <- df |> 
  mutate(CD44 = results_immune_optim$CD44) |>
  mutate(CD8a = results_immune_optim$CD8a) |> 
  mutate(CD4 = results_immune_optim$CD4) |>
  mutate(CD3 = results_immune_optim$CD3) |>
  mutate(CD20 = results_immune_optim$CD20) |>
  mutate(GCG = results_immune_optim$GCG) |>
  mutate(INS = results_immune_optim$INS) |>
  mutate(SST = results_immune_optim$SST) |> 
  mutate(NKX6_1 = results_immune_optim$NKX6_1) |>
  mutate(ProINS = results_immune_optim$ProINS)

# Uncomrpessed panel now as rowData. 
fn_panel <- file.path(paths$folder_in, paste0("panel_", "Uncompressed", ".csv"))
panel <- read.csv(fn_panel, row.names = 1)

# Create a new SCE object.
sce_immune_2 <- SpatialExperiment(
    assays = list(exprs = as.matrix(t(df_decomposed))), 
    colData = colData(sce_immune), 
    spatialCoords = spatialCoords(sce_immune),
    metadata = metadata(sce_immune),
    rowData = panel)
sce_immune_2
```

### Exocrine + Stroma + Other.
```{r}
sce_stroma$sample_id <- paste0(sce_stroma$sample_id, "_stroma")
sce_exo$sample_id <- paste0(sce_exo$sample_id, "_exo")
# sce_other$sample_id <- paste0(sce_other$sample_id, "_other")

sce_rest <- cbind(sce_stroma, sce_exo, sce_other)
```

```{r assign_exo}
set.seed(222)
results_rest  <- 
  purrr::pmap(full_coeffs, \(mu_S_Immune, mu_S_Islet, mu_N_Immune, mu_N_Islet, sigma2_S_Immune, sigma2_S_Islet, sigma2_N_Immune, sigma2_N_Islet, channel, threshold_Islet, threshold_Immune) {
    message(channel)
    
    # Optimization Interval.
    lower_bound1 <- ifelse(mu_N_Immune - sigma2_N_Immune < 0, 0, mu_N_Immune - sigma2_N_Immune)
    upper_bound1 <- ifelse(mu_N_Immune + sigma2_N_Immune > threshold_Immune, threshold_Immune, mu_N_Immune + sigma2_N_Immune)
    interval <- c(lower_bound1, upper_bound1)

    # Iterate over cells.
    furrr::future_map(1:length(colnames(sce_rest)), \(i) {
      Immune_Islet_obs <- assay(sce_rest, "exprs")[channel, ][i]
      
      result <- optimize(
        f = likelihood_n_islet_n_immune,
        interval = interval,  # N_Immune cannot exceed the N_Immune + Sigma_Immune
        maximum = TRUE,
        Immune_Islet_obs = Immune_Islet_obs,
        mu_N_Immune = mu_N_Immune,
        sigma_N_Immune = sigma2_N_Immune,
        mu_N_Islet = mu_N_Islet,
        sigma_N_Islet = sigma2_N_Islet
      )

      # Extract the results
      N_Immune_opt <- result$maximum
      N_Islet_opt <- Immune_Islet_obs - N_Immune_opt
      tibble(Immune = N_Immune_opt, Islet = N_Islet_opt)
    }) |> bind_rows()
})
results_rest_optim <- results_rest |> bind_cols()
colnames(results_rest_optim) <- channels_uncompressed
results_rest_optim
```

```{r assign-exo}
df <- as.data.frame(t(assay(sce_rest, "exprs")))

# Now add the decomposed channels.
df_decomposed <- df |> 
  mutate(CD44 = results_rest_optim$CD44) |>
  mutate(CD8a = results_rest_optim$CD8a) |> 
  mutate(CD4 = results_rest_optim$CD4) |>
  mutate(CD3 = results_rest_optim$CD3) |>
  mutate(CD20 = results_rest_optim$CD20) |>
  mutate(GCG = results_rest_optim$GCG) |>
  mutate(INS = results_rest_optim$INS) |>
  mutate(SST = results_rest_optim$SST) |> 
  mutate(NKX6_1 = results_rest_optim$NKX6_1) |>
  mutate(ProINS = results_rest_optim$ProINS)


# Uncomrpessed panel now as rowData. 
fn_panel <- file.path(paths$folder_in, paste0("panel_", "Uncompressed", ".csv"))
panel <- read.csv(fn_panel, row.names = 1)

# Create a new SCE object.
sce_rest_2 <- SpatialExperiment(
    assays = list(exprs = as.matrix(t(df_decomposed))), 
    colData = colData(sce_rest), 
    spatialCoords = spatialCoords(sce_rest),
    metadata = metadata(sce_rest),
    rowData = panel)

sce_rest_2
```

# Combine + save SCEs

```{r combine-sces}
sce <- cbind(sce_isl_2, sce_immune_2, sce_rest_2)
```

```{r save-rds-decomposed}
fn <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "decomposed.rds"))
saveRDS(sce, fn)
```

# Cell Type Annotation

We now perform cell type annotation in 3 steps. 
First, for the Islet cells using the decompressed data.


## Dimensionality Reduction to check for uncompressed marker distribution
RUN UMAP.
```{r run-umap}
cur_assay <- "exprs"
dimred_name <- paste("UMAP", cur_assay, sep = "_")
print(dimred_name)

# Run UMAP on a cell subset
#Â Extract Counts. 
if (cur_assay %in% assayNames(sce)) {
  counts <- t(assay(sce, cur_assay))
}
# Run UMAP.
umap_model <- uwot::umap(counts, ret_model = TRUE)
# Extract Embedding.
cur_umap <- umap_model$embedding
colnames(cur_umap) <- c("UMAP1", "UMAP2")
rownames(cur_umap) <- rownames(counts)

reducedDim(sce, dimred_name) <- cur_umap
```


```{r dimred-clusters}
cur_dat <- makePerCellDF(sce, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = metadata(sce)$cases),
                donor_type = factor(donor_type, levels = metadata(sce)$stages)) |>
  dplyr::arrange(case_id, donor_type)  |> 
  tibble::as_tibble()
```


```{r plot-clusters}
cur_assay <- "exprs"
cur_method <- "Pheno1"
cur_dimred <- "UMAP"

dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
clust_name <- paste(cur_method, cur_assay, sep = "_")

# Plot all clustersdat, dimred, color_by
p <- plot_dim_red(dat = cur_dat, dimred = dimred_name, color_by = "cell_category",
                  sample = TRUE, size = 0.1, alpha = 1)
if (do_print) print(p)
fn <- paste0(paste(today, "Categories_Decomposed", clust_name, cur_dimred,
                    sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))
```


## Islet Cells:
```{r}
channels_islet <- c("GCG", "PCSK2", # Alpha-Cells:
                    "INS", "SST", "NKX6_1", "ProINS", "IAPP", # Beta-cells:
                    "SST", "PDX1", # Delta-cells. PDX1 also beta-cells
                    "PPY", # Gamma cells.
                    "SYP", "CD99", "ECDH" # General markers.
                    )

sce_isl_3 <- sce[channels_islet, sce$cell_category == "Islet"]
sce_isl_3
```


## **Clustering: PhenoGraph**

```{r phenograph-run}
clust_method <- c("Pheno1")
cur_assay <- "exprs"
# Number of nearest-neighbors
k <- 30

## 
clust_name <- paste(clust_method, cur_assay, sep = "_")
writeLines(c("\n", clust_name))

# Run Phenograph
if (!clust_name %in% colnames(colData(sce_isl_3))) {
  set.seed(seed)
  cur_pheno_annoy <- Rphenoannoy::Rphenoannoy(t(assay(sce_isl_3, cur_assay)), k = k)

  cur_pheno <- DataFrame(cur_pheno_annoy[[2]]$membership)
  colnames(cur_pheno) <- clust_name
  rownames(cur_pheno) <- colnames(assay(sce_isl_3, cur_assay))

  # Add Phenograph clusters to the colData of the SCE object
  # Cluster `0` is attributed to non-subsetted cells and not islet cells
  colData(sce_isl_3)[, clust_name] <- cur_pheno
  remove(cur_pheno)
}
```

## Heatmap of marker expression by cluster

Quickly check cluster abundances.
```{r}
clust_freq <- table(colData(sce_isl_3)[[clust_name]])
clust_freq
```


```{r heatmap-clusters-markers}
cur_method <- "Pheno1"
name_cur_assay <- "exprs"
cur_assay <- "exprs"

clust_name <- paste(cur_method, cur_assay, sep = "_")
message(clust_name)
message(name_cur_assay)
# Summarize the data
hm <- summarize_heatmap(sce_isl_3,
                        expr_values = name_cur_assay,
                        cluster_by = clust_name,
                        channels = channels_islet)

# Display the heatmap
fn <- paste0(paste(today, "Clusters", clust_name, "ISLET", "Heatmap",
                    sep = "_"), ".html")
heatmaply::heatmaply(
    heatmaply::normalize(hm), main = clust_name, 
    file = file.path(paths$folder_script, fn))
```

Looks more or less okay, just NKX6.1 clusters wih SST, which is not ideal.

```{r cellcats-pheno-scaled}
clust_methods <- c("Pheno1")
clust_assay <- c("exprs")

clust_name <- paste(clust_methods, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
clust_other <- c(11, 13, 14)
clust_delta <- c(1, 12)
clust_beta <- c(9, 10, 7, 6, 4)
clust_gamma <- c(18)
clust_alpha <- c(15, 16, 17, 8, 5, 2, 3)
all_clust <- sort(c(clust_other, clust_delta, clust_beta, clust_gamma,
                    clust_alpha))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce_isl_3)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_isl_3)[colData(sce_isl_3)[, clust_name] %in% clust_beta,
                   "cell_type"] <- "Beta"
colData(sce_isl_3)[colData(sce_isl_3)[, clust_name] %in% clust_alpha,
                   "cell_type"] <- "Alpha"
colData(sce_isl_3)[colData(sce_isl_3)[, clust_name] %in% clust_delta,
                   "cell_type"] <- "Delta"
colData(sce_isl_3)[colData(sce_isl_3)[, clust_name] %in% clust_gamma,
                   "cell_type"] <- "Gamma"
colData(sce_isl_3)[colData(sce_isl_3)[, clust_name] %in% clust_other,
                   "cell_type"] <- "Other"
```

```{r beta-cell-abundance}
# Quick beta-cell check
colData(sce_isl_3) |> 
  as_tibble() |> 
  dplyr::count(case_id, cell_type, donor_type) |> 
  arrange(cell_type)
```

## Immune Cells:
```{r}
channels_immune <- c("CD3", "CD4", "CD8a", "CD45RA", "FOXP3", # T-cells: 
                    "CD20", # B-cells. Likely almost absent.
                    "CD44", 
                     "CD68", # Macrophages.
                    "MPO") # Neutrophils.

sce_immune_3 <- sce_immune_2[channels_immune, ]
```


## **Clustering: PhenoGraph**

```{r phenograph-run}
## 
clust_name <- paste(clust_method, cur_assay, sep = "_")
writeLines(c("\n", clust_name))

# Run Phenograph
if (!clust_name %in% colnames(colData(sce_immune_3))) {
  set.seed(seed)
  cur_pheno_annoy <- Rphenoannoy::Rphenoannoy(t(assay(sce_immune_3, cur_assay)), k = k)

  cur_pheno <- DataFrame(cur_pheno_annoy[[2]]$membership)
  colnames(cur_pheno) <- clust_name
  rownames(cur_pheno) <- colnames(assay(sce_immune_3, cur_assay))

  # Add Phenograph clusters to the colData of the SCE object
  # Cluster `0` is attributed to non-subsetted cells and not islet cells
  colData(sce_immune_3)[, clust_name] <<- cur_pheno
  remove(cur_pheno)
}
```




## Exocrine + Stroma Cells:
```{r}

channels_exo <- c("ECDH", "CD44", # Pan-Exo 
                  "KRT19", "PDX1", # Ductal cells
                  "SMA", # Smooth Muscle; Activated Fibroblasts.
                  "AMY", # Acinar
                  "CAIX", # 
                  "CD31") # Endothelial)

sce_exo_3 <- sce_exo[channels_exo, ]
```



## **Clustering: PhenoGraph**

```{r phenograph-run}
## 
clust_name <- paste(clust_method, cur_assay, sep = "_")
writeLines(c("\n", clust_name))

# Run Phenograph
if (!clust_name %in% colnames(colData(sce_exo_3))) {
  set.seed(seed)
  cur_pheno_annoy <- Rphenoannoy::Rphenoannoy(t(assay(sce_exo_3, cur_assay)), k = k)

  cur_pheno <- DataFrame(cur_pheno_annoy[[2]]$membership)
  colnames(cur_pheno) <- clust_name
  rownames(cur_pheno) <- colnames(assay(sce_exo_3, cur_assay))

  # Add Phenograph clusters to the colData of the SCE object
  # Cluster `0` is attributed to non-subsetted cells and not islet cells
  colData(sce_exo_3)[, clust_name] <<- cur_pheno
  remove(cur_pheno)
}
```



### Save SCE
```{r save-sce}
FIXME: adjust here.
fn_spe <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
message(assayNames(sce))
message(reducedDimNames(sce))
saveRDS(sce, fn_spe)
```



# **Visualize clusters**

## Load packages

```{r packages3, results="hide"}
suppressPackageStartupMessages(c(
  library(heatmaply),
  library(htmltools)#,
  #library(cytomapper)
))
```


## Visualize clusters on reduced dimensions



## Visualize clusters with cytomapper

### Select cluster(s) and assay to show

```{r viz-clust-select}
viz_clust <- NULL # Select cluster(s) to visualize.
viz_method <- "Pheno1"
viz_assay <- "scaled"
```

### Load images and masks

```{r viz-cluster-load}
if (!is.null(viz_clust)) {
  nb_images <- 14
  image_extension <- ".tiff"
  clust_name <- paste(viz_method, viz_assay, sep = "_")

  # Subset the SCE
  sce_viz <- sce[, colData(sce)[[clust_name]] %in% viz_clust]

  # Select random image.
  set.seed(seed)
  image_sub <- sort(sample(
    unique(sce_viz$image_fullname),
  min(length(unique(sce_viz$image_fullname)), nb_images)))

  # Folders
  folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
  folder_masks <- file.path(paths$folder_in, "masks_cells",
                            paths$panel_type, "whole-cell")

  # Load images and masks
  images <- yoloader(
    x = sce_viz,
    image_dir = folder_images,
    image_names = image_sub,
    type = "stacks"
  )

  masks <- yoloader(
    x = sce_viz,
    image_dir = folder_masks,
    image_names = image_sub,
    as.is = TRUE,
    type = "masks"
  )

  sce_viz <- sce_viz[, sce_viz$image_fullname %in% image_sub]
  sce_viz$ImageName <- gsub(image_extension, "", sce_viz$image_fullname)
}
```

### Interactive with Cytoviewer

```{r viz-cluster-cytoviewer}
# Use cytoviewer with images, masks and object
# library(cytoviewer)
if (!is.null(viz_clust)) {
  channels_view <- channels_clust
  sub_images <- cytomapper::getChannels(images, channels_view)
  app <- cytoviewer(image = sub_images, 
                    mask = masks, 
                    object = sce_viz[channels_view, ], 
                    img_id = "ImageName", 
                    cell_id = "cell_number")

  if (interactive()) {
    shiny::runApp(app)
  }
}
```



# **Attribute cell categories**

**Note: this section requires manual intervention**

Here, clusters obtained at the previous steps are manually merged into meaningful cell categories.
Cluster numbers are attributed to the different cell types based on the plots and heatmaps above. 
Consequently, this attribution has to be adapted to the clustering results.

## Cell category attribution

Cell category attribution has to be performed for every combination of clustering methods and selected assays.

### Phenograph x scaled counts

Depending on the clustering, maybe select other categories.

```{r cellcats-pheno-scaled}
clust_methods <- c("Pheno1")
clust_assay <- c("scaled")

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")
if (length(clust_assay) != 1)
  stop("Select only one assay")

clust_name <- paste(clust_methods, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
clust_immune <- c()
clust_islet  <- c()
clust_ductal <- c()
clust_acinar <- c()
clust_exocrine <- c()
clust_fibro_endo <- c()
clust_other <- c()

all_clust <- sort(c(clust_immune, clust_islet, clust_ductal, clust_acinar,
                    clust_exocrine, clust_fibro_endo, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce)[colData(sce)[, clust_name] %in% clust_immune,
             paste("CellCat", clust_name, sep = "_")] <- "Immune"
colData(sce)[colData(sce)[, clust_name] %in% clust_islet,
             paste("CellCat", clust_name, sep = "_")] <- "Islet"
colData(sce)[colData(sce)[, clust_name] %in% clust_ductal,
             paste("CellCat", clust_name, sep = "_")] <- "Ductal"
colData(sce)[colData(sce)[, clust_name] %in% clust_acinar,
             paste("CellCat", clust_name, sep = "_")] <- "Acinar"
colData(sce)[colData(sce)[, clust_name] %in% clust_exocrine,
             paste("CellCat", clust_name, sep = "_")] <- "Exocrine"
colData(sce)[colData(sce)[, clust_name] %in% clust_fibro_endo,
             paste("CellCat", clust_name, sep = "_")] <- "Fibro_Endo"
colData(sce)[colData(sce)[, clust_name] %in% clust_other,
             paste("CellCat", clust_name, sep = "_")] <- "Other"
```



## Visualize attributed categories

```{r assay-sel}
assay_sel <- c("scaled")
names(assay_sel) <- c("scaled")
```

### Plot cell types on reduced dimensions


```{r cellcats-dimred}
# Prepare the data
cur_dat <- makePerCellDF(sce[, metadata(sce)$subset], use_dimred = TRUE) |>
  mutate(case_id = factor(case_id, levels = metadata(sce)$cases),
         donor_type = factor(donor_type, levels = metadata(sce)$stages)) |>
  arrange(case_id, donor_type)

# Plot
purrr::map(assay_sel, \(cur_assay) {
  purrr::map(dimred_sel, \(cur_dimred) {
    purrr::map(methods_sel, \(cur_method) {
      dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
      clust_name <- paste("CellCat", cur_method, cur_assay,
                          sep = "_")

      p <- plot_dim_red(cur_dat, dimred_name, clust_name,
                        sample = TRUE, size = 0.1, alpha = 1)
      if (do_print) { print(p)}

      fn <- paste0(paste(today, clust_name, cur_dimred,
                         sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param))
    })
  })
})
```

### Cell categories heatmap

```{r cellcats-heatmap}
hmlist <- list()
n <- 1
purrr::map2(assay_sel, names(assay_sel), \(cur_assay, name_cur_assay) {
  purrr::map(methods_sel, \(cur_method) {
    clust_name <- paste("CellCat", cur_method, cur_assay, sep = "_")

    # Summarize the data
    hm <- summarize_heatmap(sce[, meta$subset],
                            expr_values = name_cur_assay,
                            cluster_by = clust_name,
                            channels = channels_clust)

    # Display the heatmap
    fn <- paste0(paste(today, clust_name, "Heatmap",
                       sep = "_"), ".html")

    hmlist[[n]] <- heatmaply(
      heatmaply::normalize(hm), main = clust_name,
      file = file.path(paths$folder_script, fn))
    n <- n + 1
  })
})
htmltools::tagList(setNames(hmlist, NULL))
```

### Visualize categories with cytomapper

Load the masks

```{r viz-cellcats-load}
nb_images <- 14
image_extension <- ".tiff"
# clust_name <- paste(viz_method, viz_assay, sep = "_")

set.seed(seed)
image_sub <- sort(sample(
  unique(sce$image_fullname),
  min(length(unique(sce$image_fullname)), nb_images)))

# Subset the SCE to subsampled images
sce_sub <- sce[, sce$image_fullname %in% image_sub]
sce_sub$ImageName <- gsub(image_extension, "", sce_sub$image_fullname)

# Folders
folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
folder_masks <- file.path(paths$folder_in, "masks_cells",
                          paths$panel_type, "whole-cell")

# Load masks
masks <- yoloader(
  x = sce_sub,
  image_dir = folder_masks,
  image_names = image_sub,
  as.is = TRUE,
  type = "masks"
)
```

Plot the images

```{r viz-cellcats-plot}
purrr::map(assay_sel, \(cur_assay) {
  purrr::map(methods_sel, \(cur_method) {
    celltype_viz <- paste("CellCat", cur_method, cur_assay,
                          sep = "_")

    colour_key <- list(c(
      Immune = palettes$colors[1], Islet = palettes$colors[8],
      Ductal = palettes$colors[5], Acinar = palettes$colors[4],
      Exocrine = palettes$colors[3], Fibro_Endo = palettes$colors[11],
      Other = palettes$colors[13]))
    names(colour_key) <- celltype_viz

    fn <- list(filename = file.path(
      plotsave_param$path,
      paste0(paste(today, "Cytomapper", celltype_viz, sep = "_"), ".png")))

    cytomapper::plotCells(masks, object = sce_sub,
              cell_id = "cell_number", img_id = "ImageName",
              colour_by = celltype_viz, colour = colour_key, save_plot = fn)
  })
})
```



# **Consensus cell categories**

Attribute consensus cell categories based on the clustering performed in the previous script.

## Load packages

```{r packages4, results="hide"}
suppressPackageStartupMessages(c(
  library(ggalluvial)
))
```


## Attribute temporary cell types

Exocrine cells are grouped into a single category and the ductal/acinar types are stored into temporary cell types.
For the other cells, the attributed cell type corresponds to the cell category. 
Precise cell types will be refined in downstream scripts.

```{r attribute-celltypes}
purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    celltype_name <- paste("CellType", clust_name, sep = "_")
    cellcat_name <- paste("CellCat", clust_name, sep = "_")

    colData(sce)[, celltype_name] <<- colData(sce)[, cellcat_name]

    colData(sce)[colData(sce)[, cellcat_name] %in% c(
      "Exocrine", "Acinar", "Ductal"), cellcat_name] <<- "exocrine"
    colData(sce)[colData(sce)[, cellcat_name] == "Immune",
                 cellcat_name] <<- "immune"
    colData(sce)[colData(sce)[, cellcat_name] == "Islet",
                 cellcat_name] <<- "islet"
    colData(sce)[colData(sce)[, cellcat_name] == "Fibro_Endo",
                 cellcat_name] <<- "mesenchymal_endothelial"
    colData(sce)[colData(sce)[, cellcat_name] == "Other",
                 cellcat_name] <<- "other"
  })
})
```


## Cell category concordance

Compare concordance of cell categories attributed using different methods.

```{r cellcats-concordance}
cellcat_cols <- colnames(colData(sce))[grepl(paste0(
  "CellCat_", methods_sel, collapse = "|"), colnames(colData(sce)))]

cell_categories <- as.data.table(colData(sce)[
  , c("cell_id", "case_id", "image_number", "cell_number", cellcat_cols)])

ccat_combination <- t(combn(unique(cellcat_cols), 2))

for (i in seq_len(nrow(ccat_combination))) {
  cat("\n", ccat_combination[i, 1], " vs ", ccat_combination[i, 2], "\n")

  ccat_concord <- nrow(cell_categories[
    get(ccat_combination[i, 1]) == get(ccat_combination[i, 2]), ]
  )
  ccat_discord <- nrow(cell_categories[
    get(ccat_combination[i, 1]) != get(ccat_combination[i, 2]), ]
  )
  cat("Number of cells with concordant cell categories: ", ccat_concord,
      "\nNumber of cells with discordant cell categories: ", ccat_discord,
      "\nPercentage of cells with concordant cell categories:",
      100 * ccat_concord / (ccat_discord + ccat_concord), "%", "\n")
}
```
Pheno1-scaled vs Leiden1-fastMNN: 79% (88%)
Pheno1-scaled vs Pheno1-fastMNN: 74% (83%)
Pheno1-scaled vs Leiden1-scaled: 91.2 % (92.6%)
Leiden1-fastMNN vs Pheno1-fastMNN: 77 % (88%)
Pheno1-fastMNN vs Leiden1-scaled: 72 % (82%)
Leiden1-fastMNN vs Leiden1-scaled: 74 % (85 %)

## Attribute consensus cell categories

### Majority vote

Here, we remove Pheno1-fastMNN. 
Cells for which 2 out of 3 methods agree on the cell categories are attributed this category, other cells as considered as "ambiguous".

```{r consensus-cell-categories}
# Remove a column matching "Pheno1_fastMNN"
# Use grep to find the column that matches the pattern "Pheno1-fastMNN"
column_to_remove <- grep("Pheno1_fastMNN", names(cell_categories))

# Remove the column by setting it to NULL
cell_categories[, (column_to_remove) := NULL]

# Majority vote
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

cell_categories[, cell_category := apply(cell_categories, 1, Mode)]
cell_categories[, Paste := do.call(paste0, .SD),
                .SDcols = grep("CellCat_", colnames(cell_categories))]
cell_categories[, count := stringr::str_count(Paste, cell_category)]
cell_categories[count < 2, cell_category := "ambiguous"]
cell_categories[, `:=`(Paste = NULL, count = NULL)]

cat("Percentage of cells with an ambiguous cell type: ", 100 * nrow(
  cell_categories[cell_category == "ambiguous"]) / nrow(cell_categories), "%")
```

### Compare cell type attributions

```{r cellcat-alluvial, warning=FALSE}
cellcat_cols <- c("cell_category", colnames(colData(sce))[grepl(paste0(
  "CellCat_", methods_sel, collapse = "|"), colnames(colData(sce)))])

cellcat_cols <- cellcat_cols[-grep("Pheno1_fastMNN", cellcat_cols)]

p <- cell_categories[, .(number = .N), by = cellcat_cols] |>
  ggplot(aes(axis1 = get(cellcat_cols[1]),
             axis2 = get(cellcat_cols[2]),
             axis3 = get(cellcat_cols[3]),
             axis4 = get(cellcat_cols[4]),
             # axis5 = get(cellcat_cols[5]),
             y = number)) +
  geom_stratum() +
  geom_text(stat = "stratum", infer.label = TRUE) +
  geom_alluvium(aes(fill = get(cellcat_cols[1]))) +
  scale_x_discrete(limits = gsub("cell_category_", "", cellcat_cols)) +
  scale_fill_manual(values = palettes$colors[c(TRUE, FALSE)],
                    name = "Cell category") +
  mytheme$standard() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
if (do_print) { print(p)}

fn <- paste0(paste(today, "CellCat", "alluvial", sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))
```

### Number of cells by cell category

```{r cells-per-category}
as_tibble(cell_categories) |>
  select(cell_category) |>
  group_by(cell_category) |>
  add_count(name = "Number of cells") |>
  distinct()
```




REMOVE UNNEEDED COLUMNS:
CellType_Pheno1_scaled / CellType_Leiden1_scaled 
CellType_Pheno1_fastMNN / CellType_Leiden1_fastMNN
Pheno1_fastMNN / Leiden1_fastMNN / Pheno1_scaled / Leiden1_scaled 




## Add celltypes to the main SCE

```{r add-celltypes-sce}
cell_categories <- cell_categories[order(match(cell_categories$cell_id,
                                               colnames(sce))), ]
colData(sce)$cell_category <- cell_categories$cell_category
```



# **Plot cell categories**

## Reduced dimensions

Plot consensus cell categories on reduced dimensions

```{r consensus-dimred}
ccat <- c("immune", "islet", "exocrine", "mesenchymal_endothelial",
          "ambiguous", "other")
names(ccat) <- c("Immune", "Islet", "Exocrine", "Mesenchymal_Endothelial",
                 "Ambiguous", "Other")
palette_ccat <- c(palettes$colors[1:(length(ccat) - 2)], "grey40", "grey")
names(palette_ccat) <- ccat


cur_dat <- scuttle::makePerCellDF(sce[, colnames(sce) %in% metadata(sce)$subset],
                                  use_dimred = TRUE) |>
  mutate(case_id = factor(case_id, levels = metadata(sce)$cases),
         donor_type = factor(donor_type, levels = metadata(sce)$stages)) |>
  arrange(case_id, donor_type)

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(dimred_sel, \(cur_dimred) {
    dimred_name <- paste(cur_dimred, cur_assay, sep = "_")

    p <- plot_dim_red(cur_dat, dimred_name, "cell_category",
                      sample = TRUE, size = 0.1, alpha = 1,
                      palette = palette_ccat)
    if (do_print) print(p)

    fn <- paste0(paste(today, "CellCat", "Consensus", dimred_name,
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param))
  })
})
```

## Heatmap

```{r consensus-heatmap}
hmlist <- list()

purrr::map(assay_sel, \(cur_assay) {
  clust_name <- paste("cell_category", cur_assay, sep = "_")

  # Summarize the data
  hm <- summarize_heatmap(sce,
                          expr_values = cur_assay,
                          cluster_by = "cell_category",
                          channels = channels)

  # Display the heatmap
  fn <- paste0(paste(today, "CellCat", "Consensus", cur_assay,
                     "Heatmap", sep = "_"), ".html")

  hmlist[[i]] <- heatmaply(
    heatmaply::normalize(hm), main = clust_name,
    file = file.path(paths$folder_script, fn))
})
htmltools::tagList(setNames(hmlist, NULL))
```


## Correlation between channels

```{r cell-category-correlation}
# Define the correlation method
cor_method <- "pearson"

# Function to calculate p values
cor_test_p <- function(x) {
  FUN <- function(x, y) cor.test(x, y, method = cor_method)[["p.value"]]
  z <- outer(
    colnames(x),
    colnames(x),
    Vectorize(function(i, j) FUN(x[, i], x[, j]))
  )
  dimnames(z) <- list(colnames(x), colnames(x))
  z
}

hmlist <- list()
purrr::map2(assay_sel, names(assay_sel), \(cur_assay, name_cur_assay) {

  # Summarize the data
  hm <- summarize_heatmap(sce,
                          expr_values = name_cur_assay,
                          cluster_by = "cell_category",
                          channels = channels)

  # Run the correlation test
  r <- cor(hm, method = cor_method)
  p <- cor_test_p(hm)
  diag(p) <- NA

  # Plot and save the heatmap
  fn <- paste0(paste(today, "CellCat", "Consensus", "Correlation",
                     cur_assay, sep = "_"), ".html")

  hmlist[[i]] <- heatmaply::heatmaply_cor(
    r, node_type = "scatter",
    point_size_mat = -log10(p), point_size_name = "-log10(p-value)",
    label_names = c("x", "y", "Correlation"),
    main = paste("Cell type -", cur_assay),
    file = file.path(paths$folder_script, fn))
})
htmltools::tagList(setNames(hmlist, NULL))
```

## Images

Load random images and masks

```{r consensus-viz-load}
nb_images <- 14
image_extension <- ".tiff"

# Folders
folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
folder_masks <- file.path(paths$folder_in, "masks_cells",
                          paths$panel_type, "whole-cell")

# Select random images and the associated masks
set.seed(seed)
image_list <- list.files(folder_images)
image_list <- mask_list <- sort(sample(unique(image_list), nb_images))
writeLines(c("Selected images:", image_list))

# Load images and masks
images <- yoloader(
  x = sce,
  image_dir = folder_images,
  image_names = image_list,
  type = "stacks"
)

masks <- yoloader(
  x = sce,
  image_dir = folder_masks,
  image_names = mask_list,
  as.is = TRUE,
  type = "masks"
)

if (length(setdiff(mcols(images)$ImageName,
                   mcols(masks)$ImageName)) != 0) {
  print("mcols(images)$ImageName and mcols(masks)$ImageName
        should have the same values")
}

# Subset the SCE object
sce_viz <- sce[, sce$image_fullname %in% image_list]
sce_viz$ImageName <- gsub(image_extension, "", sce_viz$image_fullname)
```

Plot the images

```{r viz-celltype-plot}
fn <- list(filename = file.path(
  plotsave_param$path,
  paste0(paste(today, "CellCat", "Cytomapper", sep = "_"), ".png")))

color_key <- list(c(
  immune = "red", islet = "blue",  exocrine = "yellow",
  mesenchymal_endothelial = "green",
  ambiguous = "white", other = "grey30"))
names(color_key) <- "cell_category"

image_names <- c(unique(colData(sce_viz)[, c("ImageName", "case_id")])$case_id)

cytomapper::plotPixels(images, object = sce_viz, masks,
           cell_id = "cell_number", img_id = "ImageName",
           colour_by = c("SYP", "CD163", "MPO", "CD3e", "PDX1", "CAV1"),
           outline_by = "cell_category",
           # image_title = list(text = image_names),
           colour = color_key,
           bcg = list(SYP = c(0, 5, 1), CD163 = c(0, 5, 1), MPO = c(0, 7, 1),
                      CD3e = c(0, 5, 1), PDX1 = c(0, 3, 1), CAV1 = c(0, 4, 1)),
           image_title = NULL, scale = TRUE, save_plot = fn)
```



# **Save **

## Remove temporary columns

```{r remove-cellcat-columns}
cellcat_cols <- colnames(colData(sce))[grep("CellCat_", colnames(colData(sce)))]
colData(sce)[, cellcat_cols] <- NULL
```

## Convert to SPE
